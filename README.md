(generated by chatgpt, update by me)
# 🧩 Elastic Collisions in 2D — Progress Tracker

> A C++20 + Raylib physics simulation project focused on real-time 2D elastic collisions, numerical stability, and performance tuning.

---

## 📅 Project Overview

| Item | Details |
|------|----------|
| **Language** | C++20 |
| **Graphics** | Raylib |
| **Build System** | CMake (Clang / GCC) |
| **Goal** | Build a physically accurate, real-time 2D elastic particle simulator with energy and momentum conservation |
| **Start Date** | 2025-10-20 |
| **Status** | 🚧 In Progress |

---

## ✅ Roadmap & Progress

### Phase 1 — Core Simulation Logic
- [ ] Define `Particle` struct 
- [ ] Implement `Simulation` class
- [ ] Add time integration 
- [ ] Detect wall collisions
- [ ] Detect particle–particle collisions
- [ ] Resolve velocity updates using elastic collision equations
- [ ] Add positional correction to prevent overlap

### Phase 2 — Data & Debug
- [ ] Add logging system 
- [ ] Record kinetic energy, total momentum each frame
- [ ] Verify conservation laws (unit tests)
- [ ] Implement reading from setting file for N, dt, runtime

### Phase 3 — Visualization (Raylib)
- [ ] Basic 2D rendering loop
- [ ] Draw particles and bounding box
- [ ] Color particles by speed
- [ ] Pause/Resume simulation input
- [ ] Display energy and collision stats on screen

### Phase 4 — Performance & Optimization
- [ ] Profile baseline O(N²) loop
- [ ] Implement broadphase
- [ ] Compare performance scaling with N
- [ ] Enable LTO & compiler optimization flags
- [ ] Test float vs double precision accuracy

### Phase 5 — Polish
- [ ] Write README and usage instructions
- [ ] Add config file support (`config.ini` or CLI)
- [ ] Record demo video / GIF
- [ ] Final cleanup and refactor

---

## 🧪 Test Checklist

| Test | Description | Status |
|------|--------------|--------|
| Two-body head-on | Equal mass swap velocities | ☐ |
| Unequal mass collision | Check momentum & energy conservation | ☐ |
| Wall reflection | Correct reversal of velocity | ☐ |
| Many-body random | Stable over long run | ☐ |
| Energy drift | ΔE < 1e-6 over 10k frames | ☐ |

---

## 🧮 Experiment Log (THIS IS PLACEHOLDER)

| Date | Experiment | Description | Result |
|------|-------------|--------------|--------|
| YYYY-MM-DD | Broadphase grid | Implemented grid size = 2× avg radius | ✅ Improved FPS 2× |
| YYYY-MM-DD | Double → float | Tested numerical drift | ⚠️ Slight energy loss |
| YYYY-MM-DD | Δt tuning | 1/60 vs 1/120 | ✅ Stable up to 1/120 |

---

## 🐞 Bug / Issue Log (THIS IS PLACEHOLDER)

| Date | Issue | Fix Status | Notes |
|------|--------|-------------|-------|
| YYYY-MM-DD | Particles occasionally overlap | 🕐 Investigating | May need iterative collision resolution |
| YYYY-MM-DD | NaN velocities after multiple collisions | ✅ Fixed | Division by zero when distance ≈ 0 |
| YYYY-MM-DD | ASan crash at exit | 🕐 Pending | Likely raylib cleanup issue |

---

## 📈 Performance Notes (THIS IS PLACEHOLDER)

| Metric | Baseline | Optimized | Notes |
|---------|-----------|-----------|-------|
| N = 100 | 60 FPS | — | |
| N = 500 | 15 FPS | 40 FPS | With grid |
| N = 1000 | 5 FPS | 20 FPS | With grid + LTO |
| Build time | 3.2s | 2.1s | With Ninja + `-j` |

---

## 💡 Future Ideas
- [ ] Add gravity and damping (non-perfect collisions)
- [ ] 3D extension (spheres)
- [ ] Parallelize collision detection (OpenMP or std::async)
- [ ] Add GUI controls for dt, particle count
- [ ] Export frame data to Python for analysis

---

## 🧰 Tooling
| Tool | Purpose |
|------|----------|
| **CMake** | Build system |
| **Clang** | Compilation |
| **clangd** | IntelliSense |
| **Raylib** | Graphics |
| **AddressSanitizer** | Memory debugging |
| **Valgrind** | Leak detection |
| **Perf** | Profiling |

---

## 🗂️ Folder Layout

📦 **elastic2d/**
├── 📁 include/
│   ├── simulation_constants.hpp
│   └── simulation_settings.hpp
├── 📁 src/
│   ├── main.cpp
│   ├── simulation.cpp
├── 📁 data/
|   ├── settings.ini
│   ├── frames.csv (eventually)
│   └── stats.csv (eventually)
├── 📁 build/
└── 📄 CMakeLists.txt


---

## 🧾 Notes & Reflections
- [ ] Lessons learned on numerical stability
- [ ] Compiler flag benchmarks
- [ ] Future optimization opportunities

---